---
title: "JSON模式"
description: "结构化输出控制和数据格式化"
---

# JSON模式

JSON模式（JSON Mode）是智能体输出结构化数据的重要功能，确保AI生成的内容符合预定义的JSON格式，便于程序化处理和系统集成。

## 功能特性

### 结构化输出
- 严格的JSON格式控制
- 自定义数据结构
- 类型验证和约束
- 嵌套对象支持

### 灵活配置
- 动态schema定义
- 可选字段控制
- 默认值设置
- 数据验证规则

### 高可靠性
- 格式保证
- 错误处理
- 重试机制
- 数据完整性检查

## 基础用法

### 启用JSON模式

```bash
curl -X POST "https://open.bigmodel.cn/api/paas/v4/chat/completions" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -d '{
    "model": "glm-4-plus",
    "messages": [
      {
        "role": "user",
        "content": "请分析这段文本的情感倾向：今天天气真好，心情特别愉快！"
      }
    ],
    "response_format": {
      "type": "json_object"
    }
  }'
```

### Python实现

```python
import requests
import json
from typing import Dict, Any, Optional, List
from pydantic import BaseModel, Field
import jsonschema

class JSONModeAgent:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://open.bigmodel.cn/api/paas/v4/chat/completions"
    
    def generate_json_response(self, prompt: str, schema: Dict[str, Any] = None, 
                             model: str = "glm-4-plus") -> Dict:
        """
        生成JSON格式的响应
        
        Args:
            prompt: 用户提示
            schema: JSON schema定义
            model: 使用的模型
        
        Returns:
            结构化的JSON响应
        """
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}"
        }
        
        # 构建提示词，包含schema要求
        if schema:
            schema_text = json.dumps(schema, indent=2, ensure_ascii=False)
            enhanced_prompt = f"""
            {prompt}
            
            请严格按照以下JSON schema格式返回结果：
            {schema_text}
            
            只返回JSON格式的数据，不要包含其他文字说明。
            """
        else:
            enhanced_prompt = f"{prompt}\n\n请以JSON格式返回结果。"
        
        data = {
            "model": model,
            "messages": [
                {"role": "user", "content": enhanced_prompt}
            ],
            "response_format": {
                "type": "json_object"
            },
            "temperature": 0.1  # 降低随机性以提高格式一致性
        }
        
        response = requests.post(self.base_url, headers=headers, json=data)
        result = response.json()
        
        if 'choices' in result and len(result['choices']) > 0:
            content = result['choices'][0]['message']['content']
            try:
                json_data = json.loads(content)
                
                # 验证schema
                if schema:
                    self._validate_schema(json_data, schema)
                
                return {
                    "success": True,
                    "data": json_data,
                    "raw_content": content
                }
            except json.JSONDecodeError as e:
                return {
                    "success": False,
                    "error": f"JSON解析失败: {str(e)}",
                    "raw_content": content
                }
            except jsonschema.ValidationError as e:
                return {
                    "success": False,
                    "error": f"Schema验证失败: {str(e)}",
                    "data": json_data,
                    "raw_content": content
                }
        else:
            return {
                "success": False,
                "error": "API调用失败",
                "response": result
            }
    
    def _validate_schema(self, data: Dict, schema: Dict):
        """
        验证JSON数据是否符合schema
        """
        jsonschema.validate(instance=data, schema=schema)
    
    def generate_with_retry(self, prompt: str, schema: Dict[str, Any] = None, 
                          max_retries: int = 3) -> Dict:
        """
        带重试机制的JSON生成
        """
        for attempt in range(max_retries):
            result = self.generate_json_response(prompt, schema)
            
            if result['success']:
                return result
            
            if attempt < max_retries - 1:
                print(f"第{attempt + 1}次尝试失败，重试中...")
        
        return result

# 使用示例
agent = JSONModeAgent("your_api_key")

# 定义情感分析的schema
sentiment_schema = {
    "type": "object",
    "properties": {
        "sentiment": {
            "type": "string",
            "enum": ["positive", "negative", "neutral"]
        },
        "confidence": {
            "type": "number",
            "minimum": 0,
            "maximum": 1
        },
        "keywords": {
            "type": "array",
            "items": {"type": "string"}
        },
        "summary": {
            "type": "string"
        }
    },
    "required": ["sentiment", "confidence", "summary"]
}

# 进行情感分析
result = agent.generate_json_response(
    "请分析这段文本的情感倾向：今天的会议很成功，团队合作非常愉快，项目进展顺利。",
    sentiment_schema
)

print(json.dumps(result, indent=2, ensure_ascii=False))
```

## 应用场景

### 1. 数据提取和结构化

```python
class DataExtractionAgent(JSONModeAgent):
    def extract_contact_info(self, text: str) -> Dict:
        """
        从文本中提取联系信息
        """
        schema = {
            "type": "object",
            "properties": {
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "name": {"type": "string"},
                            "phone": {"type": "string"},
                            "email": {"type": "string"},
                            "company": {"type": "string"},
                            "position": {"type": "string"}
                        },
                        "required": ["name"]
                    }
                },
                "total_count": {"type": "integer"}
            },
            "required": ["contacts", "total_count"]
        }
        
        prompt = f"""
        请从以下文本中提取所有联系人信息：
        
        {text}
        
        提取姓名、电话、邮箱、公司、职位等信息。
        """
        
        return self.generate_with_retry(prompt, schema)
    
    def extract_product_info(self, product_description: str) -> Dict:
        """
        提取产品信息
        """
        schema = {
            "type": "object",
            "properties": {
                "product_name": {"type": "string"},
                "brand": {"type": "string"},
                "price": {
                    "type": "object",
                    "properties": {
                        "amount": {"type": "number"},
                        "currency": {"type": "string"}
                    }
                },
                "features": {
                    "type": "array",
                    "items": {"type": "string"}
                },
                "specifications": {
                    "type": "object",
                    "additionalProperties": {"type": "string"}
                },
                "category": {"type": "string"},
                "availability": {"type": "boolean"}
            },
            "required": ["product_name", "category"]
        }
        
        prompt = f"""
        请从以下产品描述中提取结构化信息：
        
        {product_description}
        
        提取产品名称、品牌、价格、特性、规格、分类等信息。
        """
        
        return self.generate_with_retry(prompt, schema)
    
    def extract_event_info(self, event_text: str) -> Dict:
        """
        提取事件信息
        """
        schema = {
            "type": "object",
            "properties": {
                "events": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "title": {"type": "string"},
                            "date": {"type": "string", "format": "date"},
                            "time": {"type": "string"},
                            "location": {"type": "string"},
                            "description": {"type": "string"},
                            "attendees": {
                                "type": "array",
                                "items": {"type": "string"}
                            },
                            "type": {
                                "type": "string",
                                "enum": ["meeting", "conference", "workshop", "social", "other"]
                            }
                        },
                        "required": ["title", "date"]
                    }
                }
            },
            "required": ["events"]
        }
        
        prompt = f"""
        请从以下文本中提取所有事件信息：
        
        {event_text}
        
        提取事件标题、日期、时间、地点、描述、参与者、类型等信息。
        """
        
        return self.generate_with_retry(prompt, schema)

# 使用示例
extraction_agent = DataExtractionAgent("your_api_key")

# 提取联系信息
contact_text = """
张三，产品经理，ABC科技公司，电话：138-0000-1234，邮箱：zhangsan@abc.com
李四，销售总监，XYZ集团，手机：139-1111-5678，邮件：lisi@xyz.com
"""

contact_result = extraction_agent.extract_contact_info(contact_text)
print("联系信息提取结果：")
print(json.dumps(contact_result['data'], indent=2, ensure_ascii=False))

# 提取产品信息
product_text = """
iPhone 15 Pro，苹果公司最新旗舰手机，售价7999元。
主要特性：A17 Pro芯片、钛金属机身、48MP主摄像头、120Hz ProMotion显示屏。
规格：6.1英寸屏幕，256GB存储，支持5G网络，IP68防水。
"""

product_result = extraction_agent.extract_product_info(product_text)
print("\n产品信息提取结果：")
print(json.dumps(product_result['data'], indent=2, ensure_ascii=False))
```

### 2. 内容分析和分类

```python
class ContentAnalysisAgent(JSONModeAgent):
    def analyze_text_sentiment(self, text: str) -> Dict:
        """
        文本情感分析
        """
        schema = {
            "type": "object",
            "properties": {
                "overall_sentiment": {
                    "type": "string",
                    "enum": ["very_positive", "positive", "neutral", "negative", "very_negative"]
                },
                "confidence_score": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1
                },
                "emotions": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "emotion": {"type": "string"},
                            "intensity": {"type": "number", "minimum": 0, "maximum": 1}
                        }
                    }
                },
                "key_phrases": {
                    "type": "array",
                    "items": {"type": "string"}
                },
                "summary": {"type": "string"}
            },
            "required": ["overall_sentiment", "confidence_score", "summary"]
        }
        
        prompt = f"""
        请分析以下文本的情感倾向：
        
        {text}
        
        分析整体情感、置信度、具体情绪、关键短语等。
        """
        
        return self.generate_with_retry(prompt, schema)
    
    def classify_content(self, content: str, categories: List[str]) -> Dict:
        """
        内容分类
        """
        schema = {
            "type": "object",
            "properties": {
                "primary_category": {
                    "type": "string",
                    "enum": categories
                },
                "secondary_categories": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "enum": categories
                    }
                },
                "confidence_scores": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "number",
                        "minimum": 0,
                        "maximum": 1
                    }
                },
                "tags": {
                    "type": "array",
                    "items": {"type": "string"}
                },
                "reasoning": {"type": "string"}
            },
            "required": ["primary_category", "confidence_scores"]
        }
        
        categories_text = "、".join(categories)
        
        prompt = f"""
        请将以下内容分类到合适的类别中：
        
        内容：{content}
        
        可选类别：{categories_text}
        
        请选择主要类别，可选的次要类别，并给出各类别的置信度分数。
        """
        
        return self.generate_with_retry(prompt, schema)
    
    def extract_keywords(self, text: str, max_keywords: int = 10) -> Dict:
        """
        关键词提取
        """
        schema = {
            "type": "object",
            "properties": {
                "keywords": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "word": {"type": "string"},
                            "importance": {"type": "number", "minimum": 0, "maximum": 1},
                            "category": {"type": "string"}
                        },
                        "required": ["word", "importance"]
                    },
                    "maxItems": max_keywords
                },
                "main_topics": {
                    "type": "array",
                    "items": {"type": "string"}
                },
                "summary": {"type": "string"}
            },
            "required": ["keywords", "main_topics"]
        }
        
        prompt = f"""
        请从以下文本中提取最重要的{max_keywords}个关键词：
        
        {text}
        
        为每个关键词评估重要性分数，并识别主要话题。
        """
        
        return self.generate_with_retry(prompt, schema)

# 使用示例
analysis_agent = ContentAnalysisAgent("your_api_key")

# 情感分析
sentiment_text = """
今天的产品发布会非常成功！新产品得到了用户的热烈欢迎，
销售团队反馈订单量超出预期。虽然在技术演示环节出现了小问题，
但整体效果还是很棒的。团队成员都很兴奋，对未来充满信心。
"""

sentiment_result = analysis_agent.analyze_text_sentiment(sentiment_text)
print("情感分析结果：")
print(json.dumps(sentiment_result['data'], indent=2, ensure_ascii=False))

# 内容分类
content_text = """
人工智能技术在医疗领域的应用越来越广泛，从医学影像诊断到药物研发，
AI正在革命性地改变传统医疗模式。机器学习算法可以帮助医生更准确地
诊断疾病，提高治疗效果，降低医疗成本。
"""

categories = ["科技", "医疗", "教育", "金融", "娱乐", "体育", "政治", "经济"]
classification_result = analysis_agent.classify_content(content_text, categories)
print("\n内容分类结果：")
print(json.dumps(classification_result['data'], indent=2, ensure_ascii=False))
```

### 3. 结构化问答

```python
class StructuredQAAgent(JSONModeAgent):
    def answer_with_sources(self, question: str, context: str) -> Dict:
        """
        带来源的结构化问答
        """
        schema = {
            "type": "object",
            "properties": {
                "answer": {"type": "string"},
                "confidence": {"type": "number", "minimum": 0, "maximum": 1},
                "sources": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "text": {"type": "string"},
                            "relevance": {"type": "number", "minimum": 0, "maximum": 1}
                        }
                    }
                },
                "related_questions": {
                    "type": "array",
                    "items": {"type": "string"}
                },
                "answer_type": {
                    "type": "string",
                    "enum": ["factual", "opinion", "explanation", "instruction", "unknown"]
                }
            },
            "required": ["answer", "confidence", "answer_type"]
        }
        
        prompt = f"""
        基于以下上下文回答问题：
        
        上下文：{context}
        
        问题：{question}
        
        请提供详细答案、置信度、相关来源片段和相关问题建议。
        """
        
        return self.generate_with_retry(prompt, schema)
    
    def generate_faq(self, topic: str, num_questions: int = 5) -> Dict:
        """
        生成常见问题解答
        """
        schema = {
            "type": "object",
            "properties": {
                "topic": {"type": "string"},
                "faqs": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "question": {"type": "string"},
                            "answer": {"type": "string"},
                            "category": {"type": "string"},
                            "difficulty": {
                                "type": "string",
                                "enum": ["beginner", "intermediate", "advanced"]
                            },
                            "keywords": {
                                "type": "array",
                                "items": {"type": "string"}
                            }
                        },
                        "required": ["question", "answer", "category"]
                    },
                    "maxItems": num_questions
                },
                "summary": {"type": "string"}
            },
            "required": ["topic", "faqs"]
        }
        
        prompt = f"""
        请为主题 "{topic}" 生成{num_questions}个常见问题和答案。
        
        要求：
        1. 问题应该涵盖不同难度级别
        2. 答案要准确、简洁
        3. 为每个问答分配合适的分类
        4. 提取相关关键词
        """
        
        return self.generate_with_retry(prompt, schema)
    
    def create_knowledge_card(self, entity: str) -> Dict:
        """
        创建知识卡片
        """
        schema = {
            "type": "object",
            "properties": {
                "entity_name": {"type": "string"},
                "entity_type": {
                    "type": "string",
                    "enum": ["person", "place", "organization", "concept", "event", "product"]
                },
                "description": {"type": "string"},
                "key_facts": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "fact": {"type": "string"},
                            "category": {"type": "string"}
                        }
                    }
                },
                "related_entities": {
                    "type": "array",
                    "items": {"type": "string"}
                },
                "timeline": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "date": {"type": "string"},
                            "event": {"type": "string"}
                        }
                    }
                },
                "sources": {
                    "type": "array",
                    "items": {"type": "string"}
                }
            },
            "required": ["entity_name", "entity_type", "description", "key_facts"]
        }
        
        prompt = f"""
        请为实体 "{entity}" 创建一个详细的知识卡片。
        
        包含：
        1. 实体类型和描述
        2. 关键事实信息
        3. 相关实体
        4. 重要时间线（如适用）
        5. 信息来源
        """
        
        return self.generate_with_retry(prompt, schema)

# 使用示例
qa_agent = StructuredQAAgent("your_api_key")

# 结构化问答
context = """
人工智能（AI）是计算机科学的一个分支，致力于创建能够执行通常需要人类智能的任务的系统。
AI的主要技术包括机器学习、深度学习、自然语言处理和计算机视觉。
机器学习是AI的核心技术，通过算法让计算机从数据中学习模式。
深度学习是机器学习的一个子集，使用神经网络模拟人脑的工作方式。
"""

qa_result = qa_agent.answer_with_sources(
    "什么是深度学习？",
    context
)
print("结构化问答结果：")
print(json.dumps(qa_result['data'], indent=2, ensure_ascii=False))

# 生成FAQ
faq_result = qa_agent.generate_faq("Python编程入门", 3)
print("\nFAQ生成结果：")
print(json.dumps(faq_result['data'], indent=2, ensure_ascii=False))
```

## 高级功能

### 1. 动态Schema生成

```python
class DynamicSchemaAgent(JSONModeAgent):
    def generate_schema_from_example(self, example_data: Dict) -> Dict:
        """
        从示例数据生成schema
        """
        def infer_type(value):
            if isinstance(value, bool):
                return {"type": "boolean"}
            elif isinstance(value, int):
                return {"type": "integer"}
            elif isinstance(value, float):
                return {"type": "number"}
            elif isinstance(value, str):
                return {"type": "string"}
            elif isinstance(value, list):
                if value:
                    item_type = infer_type(value[0])
                    return {"type": "array", "items": item_type}
                else:
                    return {"type": "array", "items": {"type": "string"}}
            elif isinstance(value, dict):
                properties = {}
                required = []
                for k, v in value.items():
                    properties[k] = infer_type(v)
                    required.append(k)
                return {
                    "type": "object",
                    "properties": properties,
                    "required": required
                }
            else:
                return {"type": "string"}
        
        return infer_type(example_data)
    
    def generate_with_dynamic_schema(self, prompt: str, example_output: Dict) -> Dict:
        """
        使用动态生成的schema
        """
        schema = self.generate_schema_from_example(example_output)
        return self.generate_with_retry(prompt, schema)
    
    def create_custom_extractor(self, field_definitions: List[Dict]) -> Dict:
        """
        创建自定义数据提取器
        """
        properties = {}
        required = []
        
        for field in field_definitions:
            field_name = field['name']
            field_type = field['type']
            field_desc = field.get('description', '')
            is_required = field.get('required', False)
            
            if field_type == 'string':
                properties[field_name] = {"type": "string", "description": field_desc}
            elif field_type == 'number':
                properties[field_name] = {"type": "number", "description": field_desc}
            elif field_type == 'boolean':
                properties[field_name] = {"type": "boolean", "description": field_desc}
            elif field_type == 'array':
                item_type = field.get('item_type', 'string')
                properties[field_name] = {
                    "type": "array",
                    "items": {"type": item_type},
                    "description": field_desc
                }
            elif field_type == 'enum':
                enum_values = field.get('values', [])
                properties[field_name] = {
                    "type": "string",
                    "enum": enum_values,
                    "description": field_desc
                }
            
            if is_required:
                required.append(field_name)
        
        return {
            "type": "object",
            "properties": properties,
            "required": required
        }

# 使用示例
dynamic_agent = DynamicSchemaAgent("your_api_key")

# 定义自定义字段
fields = [
    {"name": "title", "type": "string", "description": "文章标题", "required": True},
    {"name": "author", "type": "string", "description": "作者姓名", "required": True},
    {"name": "publish_date", "type": "string", "description": "发布日期", "required": False},
    {"name": "tags", "type": "array", "item_type": "string", "description": "标签列表", "required": False},
    {"name": "category", "type": "enum", "values": ["技术", "生活", "娱乐", "教育"], "description": "文章分类", "required": True},
    {"name": "word_count", "type": "number", "description": "字数统计", "required": False}
]

# 创建自定义提取器
custom_schema = dynamic_agent.create_custom_extractor(fields)

# 使用自定义提取器
article_text = """
标题：《深度学习在自然语言处理中的应用》
作者：张博士
发布时间：2024年3月15日
分类：技术文章
标签：深度学习、NLP、人工智能、机器学习
正文：本文介绍了深度学习技术在自然语言处理领域的最新进展...
（全文约3500字）
"""

result = dynamic_agent.generate_with_retry(
    f"请从以下文章中提取结构化信息：\n\n{article_text}",
    custom_schema
)

print("自定义提取结果：")
print(json.dumps(result['data'], indent=2, ensure_ascii=False))
```

### 2. 批量处理和验证

```python
class BatchJSONProcessor(JSONModeAgent):
    def process_batch(self, prompts: List[str], schema: Dict, 
                     max_workers: int = 3) -> List[Dict]:
        """
        批量处理JSON请求
        """
        import concurrent.futures
        import time
        
        results = []
        
        def process_single(prompt):
            try:
                return self.generate_with_retry(prompt, schema)
            except Exception as e:
                return {"success": False, "error": str(e), "prompt": prompt}
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_prompt = {executor.submit(process_single, prompt): prompt 
                              for prompt in prompts}
            
            for future in concurrent.futures.as_completed(future_to_prompt):
                prompt = future_to_prompt[future]
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    results.append({
                        "success": False, 
                        "error": str(e), 
                        "prompt": prompt
                    })
                
                # 添加延迟避免API限制
                time.sleep(0.5)
        
        return results
    
    def validate_batch_results(self, results: List[Dict], schema: Dict) -> Dict:
        """
        验证批量处理结果
        """
        validation_summary = {
            "total_count": len(results),
            "success_count": 0,
            "error_count": 0,
            "validation_errors": [],
            "success_rate": 0.0
        }
        
        for i, result in enumerate(results):
            if result.get('success', False):
                try:
                    jsonschema.validate(instance=result['data'], schema=schema)
                    validation_summary['success_count'] += 1
                except jsonschema.ValidationError as e:
                    validation_summary['validation_errors'].append({
                        "index": i,
                        "error": str(e),
                        "data": result.get('data')
                    })
            else:
                validation_summary['error_count'] += 1
        
        validation_summary['success_rate'] = (
            validation_summary['success_count'] / validation_summary['total_count']
        )
        
        return validation_summary
    
    def export_results(self, results: List[Dict], output_file: str, 
                      format: str = "json") -> bool:
        """
        导出处理结果
        """
        try:
            if format == "json":
                with open(output_file, 'w', encoding='utf-8') as f:
                    json.dump(results, f, ensure_ascii=False, indent=2)
            elif format == "csv":
                import pandas as pd
                
                # 提取成功的数据
                successful_data = [r['data'] for r in results if r.get('success', False)]
                if successful_data:
                    df = pd.json_normalize(successful_data)
                    df.to_csv(output_file, index=False, encoding='utf-8')
            
            return True
        except Exception as e:
            print(f"导出失败: {e}")
            return False

# 使用示例
batch_processor = BatchJSONProcessor("your_api_key")

# 批量情感分析
sentiment_schema = {
    "type": "object",
    "properties": {
        "sentiment": {"type": "string", "enum": ["positive", "negative", "neutral"]},
        "confidence": {"type": "number", "minimum": 0, "maximum": 1},
        "summary": {"type": "string"}
    },
    "required": ["sentiment", "confidence"]
}

sentiment_prompts = [
    "分析情感：今天天气真好，心情很愉快！",
    "分析情感：这个产品质量太差了，非常失望。",
    "分析情感：会议内容还可以，没有特别的感受。",
    "分析情感：团队合作很顺利，项目进展不错。",
    "分析情感：服务态度一般，有待改进。"
]

# 批量处理
batch_results = batch_processor.process_batch(sentiment_prompts, sentiment_schema)

# 验证结果
validation_summary = batch_processor.validate_batch_results(batch_results, sentiment_schema)
print("批量处理验证结果：")
print(json.dumps(validation_summary, indent=2, ensure_ascii=False))

# 导出结果
batch_processor.export_results(batch_results, "sentiment_analysis_results.json")
batch_processor.export_results(batch_results, "sentiment_analysis_results.csv", "csv")
```

## 性能优化

### 1. 缓存和重用

```python
import hashlib
import pickle
import os
from datetime import datetime, timedelta

class CachedJSONAgent(JSONModeAgent):
    def __init__(self, api_key: str, cache_dir: str = "./json_cache"):
        super().__init__(api_key)
        self.cache_dir = cache_dir
        os.makedirs(cache_dir, exist_ok=True)
    
    def _get_cache_key(self, prompt: str, schema: Dict = None) -> str:
        """
        生成缓存键
        """
        content = prompt + json.dumps(schema or {}, sort_keys=True)
        return hashlib.md5(content.encode()).hexdigest()
    
    def generate_json_response(self, prompt: str, schema: Dict[str, Any] = None, 
                             model: str = "glm-4-plus", use_cache: bool = True) -> Dict:
        """
        带缓存的JSON生成
        """
        if use_cache:
            cache_key = self._get_cache_key(prompt, schema)
            cache_file = os.path.join(self.cache_dir, f"{cache_key}.pkl")
            
            # 检查缓存
            if os.path.exists(cache_file):
                cache_time = datetime.fromtimestamp(os.path.getmtime(cache_file))
                if datetime.now() - cache_time < timedelta(hours=24):
                    with open(cache_file, 'rb') as f:
                        return pickle.load(f)
        
        # 生成新结果
        result = super().generate_json_response(prompt, schema, model)
        
        # 保存到缓存
        if use_cache and result.get('success', False):
            cache_key = self._get_cache_key(prompt, schema)
            cache_file = os.path.join(self.cache_dir, f"{cache_key}.pkl")
            with open(cache_file, 'wb') as f:
                pickle.dump(result, f)
        
        return result
```

### 2. 错误处理和重试策略

```python
class RobustJSONAgent(JSONModeAgent):
    def generate_with_smart_retry(self, prompt: str, schema: Dict[str, Any] = None, 
                                max_retries: int = 3) -> Dict:
        """
        智能重试机制
        """
        last_error = None
        
        for attempt in range(max_retries):
            try:
                result = self.generate_json_response(prompt, schema)
                
                if result['success']:
                    return result
                
                # 分析错误类型并调整策略
                error_msg = result.get('error', '')
                
                if 'JSON解析失败' in error_msg:
                    # JSON格式错误，增强提示
                    enhanced_prompt = f"""
                    {prompt}
                    
                    重要：请确保返回的是有效的JSON格式，不要包含任何其他文字。
                    JSON必须以 {{ 开始，以 }} 结束。
                    """
                    prompt = enhanced_prompt
                
                elif 'Schema验证失败' in error_msg:
                    # Schema验证失败，提供更详细的schema说明
                    if schema:
                        schema_explanation = self._explain_schema(schema)
                        enhanced_prompt = f"""
                        {prompt}
                        
                        请严格按照以下数据结构要求：
                        {schema_explanation}
                        """
                        prompt = enhanced_prompt
                
                last_error = result
                
            except Exception as e:
                last_error = {"success": False, "error": str(e)}
        
        return last_error or {"success": False, "error": "未知错误"}
    
    def _explain_schema(self, schema: Dict) -> str:
        """
        将schema转换为人类可读的说明
        """
        def explain_property(prop_schema, prop_name=""):
            prop_type = prop_schema.get('type', 'unknown')
            description = prop_schema.get('description', '')
            
            if prop_type == 'object':
                properties = prop_schema.get('properties', {})
                required = prop_schema.get('required', [])
                
                explanation = f"{prop_name}是一个对象，包含以下字段：\n"
                for prop, prop_def in properties.items():
                    required_mark = "(必需)" if prop in required else "(可选)"
                    explanation += f"  - {prop} {required_mark}: {explain_property(prop_def)}\n"
                
                return explanation
            
            elif prop_type == 'array':
                items_schema = prop_schema.get('items', {})
                return f"数组，每个元素是 {explain_property(items_schema)}"
            
            elif prop_type == 'string':
                enum_values = prop_schema.get('enum')
                if enum_values:
                    return f"字符串，可选值：{', '.join(enum_values)}"
                return "字符串"
            
            elif prop_type == 'number':
                minimum = prop_schema.get('minimum')
                maximum = prop_schema.get('maximum')
                if minimum is not None and maximum is not None:
                    return f"数字，范围：{minimum}-{maximum}"
                return "数字"
            
            elif prop_type == 'boolean':
                return "布尔值 (true/false)"
            
            else:
                return prop_type
        
        return explain_property(schema, "根对象")
```

## 最佳实践

### 1. Schema设计原则
- 保持简单明确的结构
- 使用描述性的字段名
- 合理设置必需字段
- 提供枚举值约束
- 添加适当的验证规则

### 2. 提示词优化
- 明确指定输出格式要求
- 提供具体的示例
- 使用清晰的指令语言
- 避免歧义表达

### 3. 错误处理
- 实施重试机制
- 记录详细的错误信息
- 提供降级方案
- 监控成功率

<Warning>
JSON模式虽然提供了结构化输出，但仍需要注意：
1. 复杂的schema可能影响生成质量
2. 过于严格的约束可能导致生成失败
3. 需要平衡结构化程度和灵活性
4. 定期验证和调整schema设计
</Warning>

<Tip>
建议从简单的schema开始，逐步增加复杂性。充分测试不同场景下的表现，根据实际使用情况优化schema设计。
</Tip>